#summary Frequently Asked Questions about BridJ
#labels Featured

= How is this different from... =

== JNA ==

Things BridJ aims at doing better than JNA :
  * Supports C++ (really : virtual methods, inheritance, templates and everything), without any symbol issue (you don't need to mess with C++ decoration)
  * Supports COM by default (special case of C++ support)
  * Cleaner API with Java 1.5 generics : typed `Pointer<T>`, typed enums (that are still flag-ORing-capable).
  This API is less ambiguous and less verbose : there's no Pointer vs. Memory vs. IntByReference issues :
{{{
import static com.bridj.Pointer.*;
...
Pointer<Integer> p = pointerToInts(1, 2, 3, 4);
for (int v : p)
  System.out.println("Next value : " + v);
}}}
  No more .ByReference vs. .ByValue issues : if a function accepts a pointer to MyStruct, it's gonna be `f(Pointer<MyStruct> s)`, if it accepts a MyStruct by value it will be `f(MyStruct s)`. Simple.

  Wanna cast a pointer to a function pointer ? 
  `ptr.as(MyFunctionPointer.class)`.
  * Built-in support for different endiannesses in Pointer : if you retrieved a pointer to some GPU-filled memory and you know the GPU is little-endian (while your CPU is big-endian), you can just call myPtr.order(ByteOrder.LITTLE_ENDIAN). You can then retrieve data from it as usual, and even cast to a struct pointer : it will just work as intended.
  * Vastly better structs support : lightweight structs without any data duplication
  * Better performance for most cases : direct mode is the default with BridJ, and it makes use of handwritten assembly to reach near-JNI performance in cases amenable for optimization.

Where JNA wins over BridJ :
  * BridJ doesn't handle structs by value in function calls yet (neither in arguments nor in return value). This is being worked on, though.
  * JNA is Java 1.4 compatible (while BridJ requires Java 1.5+)
  * JNA is mature and stable, used by *many* projects
  * BridJ supports less platforms (Windows 32/64, MacOS X Universal, Linux x86 for now)
  * BridJ interfaces are harder to write by hand than JNA's. But JNAerator supports both JNA and BridJ outputs (with BridJ output being less verbose because there's only one way to bind things), so you won't need to write any interface by hand anyway.
  * JNA has tons of working examples