#summary BridJ's Frequently Asked Questions
#labels Featured
<wiki:toc max_depth="3" />

= What is BridJ ? =

BridJ is a library that lets you call [CLanguage C], [CPlusPlus C++] and [ObjectiveC Objective-C] libraries from Java as if you were writing native code. It is a recent alternative to [http://jna.dev.java.net JNA].

With the help of [http://jnaerator.googlecode.com/ JNAerator], it provides [TypeMapping clean and unambiguous mappings] to C/C++ code and a very straightforward and highly typed API to manipulate pointers, classes, structs, unions...

It bridges Java's gap when it comes to native-world interoperability.

<table><tr valign="top"><td colspan="2">
For instance, you can allocate a `new float[10]` almost as in C++ :
{{{
float* array = new float[10];
float value = array[4];
delete[] array;
}}}
</td></tr><tr valign="top"><td>
Scala code :
{{{
import org.bridj.Pointer._

val array = allocateFloats(10);
val value = array.get(4);

// optional : will be eventually called by the Garbage Collector
array.release 
}}}
</td><td>
Java code :
{{{
import org.bridj.Pointer;
import static org.bridj.Pointer.*;
...
Pointer<Float> array = allocateFloats(10);
float value = array.get(4);
array.release();
}}}
</td></tr></table>

Read more about :
  * [BridJAndScala]
  * [Pointers]
  * [TypeMapping]
  * [CLanguage]
  * [CPlusPlus]
  * [COM]
  * [Design]

= Why another interop library ? =

In three words : [Design C++, Performance and Usability]

= What is BridJ's development status ? = 

Please read [CurrentState]

= What platforms does BridJ support ? = 

  * Windows (x86, x64)
  * Linux (x86, x64)
  * Mac OS X (x86, x64, ppc)

... with plans for FreeBSD and Solaris ([CreditsAndLicense help and / or test hardward welcome])

= Can I build BridJ from sources ? =

Sure, please read [Build].

= What is BridJ's license ? =

BridJ is [CreditsAndLicense dual-licensed under a very liberal BSD license and the very liberal Apache 2.0 license].

= What are BridJ's runtime dependencies ? =

BridJ is released as a self-contained JAR.

However, it includes a copy of the [http://asm.ow2.org/ ASM] library and its native library are statically linked with a modified version of [http://dyncall.org Dyncall].

More details here : [CreditsAndLicense].

= How do I bind C / C++ function / struct / class / type XXX with BridJ ? =

Just paste your C header [http://jnaerator.sourceforge.net/webstart/JNAerator/JNAeratorStudio.jnlp into JNAerator], choose BridJ as runtime and click on JNAerate.

= Where can I get support for BridJ ? =

On [http://groups.google.com/group/nativelibs4java NativeLibs4Java's mailing-list].

= How is BridJ different from... =

== JNA ==

Things BridJ aims at doing better than JNA :
  * BridJ is BSD-licensed (while JNA is LGPL)
  * [CPlusPlus Supports C++] (really : virtual methods, inheritance, templates...)
  * Vastly better structs : lightweight, fast (one or two orders of magnitude faster to create), without any data duplication
  * Better performance for most function calls : 
    * Direct mode is the default
    * Some calls are optimized with handwritten assembly code to reach near-JNI performance
  * [COM Supports COM] (special case of C++ support) : lets you use "real" Windows APIs (IShellFolder, ITaskBarList3...)
  * [TypeMapping Cleaner API] with Java 1.5 generics : 
    * [Pointers Iterable and typed `Pointer<T>`]
{{{
import static org.bridj.Pointer.*;
...
Pointer<Integer> p = pointerToInts(1, 2, 3, 4);
p.set(0, 10);
for (int v : p)
  System.out.println("Next value : " + v);
}}}
    * Typed enums (that can still be combined as flags)
    * No such thing as IntByReference, LongByReference... Simply use `Pointer<Integer>`, `Pointer<Long>`...
    * No such thing as Structure.ByReference vs. Structure.ByValue : if a function accepts a pointer to MyStruct, it's gonna be `f(Pointer<MyStruct> s)`, if it accepts a MyStruct by value it will be `f(MyStruct s)`. Simple.
    * Wanna cast a pointer to a function pointer ? `ptr.as(MyFunctionPointer.class)`.
  * Pervasive multiple endianness support : if you retrieved a pointer to some GPU-filled memory and you know the GPU is little-endian while your CPU is big-endian, you can just call `myPtr.order(ByteOrder.LITTLE_ENDIAN)`. You can then retrieve data from it as usual, and even cast to a struct pointer : it will just work as intended.

Where JNA wins over BridJ :
  * BridJ doesn't handle structs by value in function calls yet (neither in arguments nor in return value). This is being worked on, though.
  * JNA is Java 1.4 compatible (while BridJ requires Java 1.5+)
  * JNA is mature and stable, used by *many* projects
  * BridJ supports less platforms (Windows 32/64, MacOS X Universal, Linux x86/amd64 for now)
  * BridJ interfaces are harder to write by hand than JNA's. But [http://jnaerator.googlecode.com/ JNAerator] supports both JNA and BridJ outputs (with BridJ output being less verbose because there's only one way to bind things), so you won't need to write any interface by hand anyway.
  * JNA has tons of working examples

== SWIG == 

BridJ is better because :
  * it only requires you to build your Java program, whereas SWIG requires a painful native build on every target platform
  * the resulting API is generally nicer looking, without any manual configuration involved
  * you work directly with the original C/C++ headers, no need to write special header as with SWIG

SWIG is better because :
  * it's C++ support is much more solid : once it compiles, you're pretty sure it's gonna work (with BridJ
  * it has support for STL types (std::string, std::vector...)
  * it's more mature and stable

= Who is using BridJ ? =

  * [http://javacl.googlecode.com/ JavaCL] has an experimental port to BridJ (over from JNA) which is fully functional.

Please let us know if you want your project to be listed here :-)