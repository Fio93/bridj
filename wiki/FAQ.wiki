#summary BridJ's Frequently Asked Questions
#labels Featured
<wiki:toc max_depth="3" />

= What is BridJ ? =

BridJ is a library that lets you call [CLanguage C], [CPlusPlus C++] and [ObjectiveC Objective-C] libraries from Java as if you were writing native code.

With the help of [http://jnaerator.googlecode.com/ JNAerator], it provides [TypeMapping clean and unambiguous mappings] to C/C++ code and a very straightforward and highly typed API to manipulate pointers, classes, structs, unions...

It bridges Java's gap when it comes to native-world interoperability.

For instance, you can allocate a `new float[10]` almost as in C++ :
{{{
float* array = new float[10];
float value = array[4];
delete[] array;
}}}
{{{
import static com.bridj.Pointer.*;
...
Pointer<Float> array = allocateFloats(10);
float value = array.get(4);
array.release(); // optional : will be eventually called by the Garbage Collector
}}}

Read more about :
  * [Pointers]
  * [TypeMapping]
  * [CLanguage]
  * [CPlusPlus]
  * [COM]

= What is BridJ's development status ? = 

Please read [CurrentState]

= What platforms does BridJ support ? = 

Please read [CurrentState]

= Can I build BridJ from sources ? =

Sure, please read [Build].

= What is BridJ's license ? =

BridJ is distributed under the very liberal BSD license.
Should you feel it does not fit your needs, the author is very open to dual-licensing it to any other license compatible with its dependencies (Apache, LGPL...).

= What are BridJ's runtime dependencies ? =

BridJ depends on the following libraries :
  * [http://asm.ow2.org/ ASM] (under [http://asm.ow2.org/license.html a BSD-style license])
  * [http://dyncall.org Dyncall] (under [http://dyncall.org/license.shtml an ISC-style license])

= Where can I get support for BridJ ? =

On [http://groups.google.com/group/nativelibs4java NativeLibs4Java's mailing-list].

= How is BridJ different from... =

== JNA ==

Things BridJ aims at doing better than JNA :
  * BridJ is BSD-licensed (while JNA is LGPL)
  * [CPlusPlus Supports C++] (really : virtual methods, inheritance, templates...)
  * [COM Supports COM] (special case of C++ support) : lets you use "real" Windows APIs (IShellFolder, ITaskBarList3...)
  * Cleaner API with Java 1.5 generics : 
    * Iterable and typed `Pointer<T>`
{{{
import static com.bridj.Pointer.*;
...
Pointer<Integer> p = pointerToInts(1, 2, 3, 4);
p.set(0, 10);
for (int v : p)
  System.out.println("Next value : " + v);
}}}
    * Typed enums (that can still be combined as flags)
    * No such thing as IntByReference, LongByReference... Simply use `Pointer<Integer>`, `Pointer<Long>`...
    * No such thing as Structure.ByReference vs. Structure.ByValue : if a function accepts a pointer to MyStruct, it's gonna be `f(Pointer<MyStruct> s)`, if it accepts a MyStruct by value it will be `f(MyStruct s)`. Simple.
    * Wanna cast a pointer to a function pointer ? `ptr.as(MyFunctionPointer.class)`.
  * Pervasive multiple endianness support : if you retrieved a pointer to some GPU-filled memory and you know the GPU is little-endian while your CPU is big-endian, you can just call `myPtr.order(ByteOrder.LITTLE_ENDIAN)`. You can then retrieve data from it as usual, and even cast to a struct pointer : it will just work as intended.
  * Vastly better structs : lightweight, fast, without any data duplication
  * Better performance for most function calls : 
    * Direct mode is the default
    * Some calls are optimized with handwritten assembly code to reach near-JNI performance

Where JNA wins over BridJ :
  * BridJ doesn't handle structs by value in function calls yet (neither in arguments nor in return value). This is being worked on, though.
  * JNA is Java 1.4 compatible (while BridJ requires Java 1.5+)
  * JNA is mature and stable, used by *many* projects
  * BridJ supports less platforms (Windows 32/64, MacOS X Universal, Linux x86 for now)
  * BridJ interfaces are harder to write by hand than JNA's. But [http://jnaerator.googlecode.com/ JNAerator] supports both JNA and BridJ outputs (with BridJ output being less verbose because there's only one way to bind things), so you won't need to write any interface by hand anyway.
  * JNA has tons of working examples

== SWIG == 

BridJ is better because :
  * it only requires you to build your Java program, whereas SWIG requires a painful native build on every target platform
  * the resulting API is generally nicer looking, without any manual configuration involved
  * you work directly with the original C/C++ headers, no need to write special header as with SWIG

SWIG is better because :
  * it's C++ support is much more solid : once it compiles, you're pretty sure it's gonna work (with BridJ
  * it has support for STL types (std::string, std::vector...)
  * it's more mature and stable