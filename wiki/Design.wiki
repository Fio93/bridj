#summary Details about BridJ's design

= Introduction =

BridJ was designed with both performance and usability as golden objectives.

Performance :
  * Lightweight structs : no code duplication
  * Pervasive "direct" mode (heavy use of "native" Java methods)
  * Assembler-optimized calls in some simple cases on select plaforms (see details below)

Usability :
  * Pointer class behaves pretty much like C pointers (automatic translation is trivial)
  * Enums are typed while letting users combine them as flags
  * Create a C++ object with `new MyCPPObject()`, subclass it with `new MyCPPObject() { public void myOverriddenMethod() {} }`...
  * Structs have chainable setters : `new MyStruct().a(10).b(12)`

= Assembler optimizations =

These optimization are turned on when all conditions are met, which might be rarely or never.

Without these optimizations, BridJ's performance is about the same as JNA in direct mode (without structs, where BridJ is much faster). With the optimizations, BridJ is about 10% slower than pure JNI.

Concerns only the native C functions with primitive arguments that match the platform's size.

Supports calls with a maximum number of arguments that depends on the platform (typically, 4).

Supported platforms :
  * MacOS X 64 bits (float + double disabled)
  * Linux 64 bits (float + double disabled)
  * Windows 32 bits (currently disabled)
  * Windows 64 bits (currently disabled)

Example of optimizable function :
{{{
public static native int f(long a, short b, int c);
}}}

Examples of non-optimizable function :
{{{
public static native int fWithPointer(Pointer<?> p);
public static native int fTooManyArgs(long a, short b, int c, int d, int e, int f, int g, int h, int i);
}}}