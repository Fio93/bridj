#summary How to use pointers in BridJ
<wiki:toc max_depth="3" />

= Anatomy of a pointer =

Please read through the [http://nativelibs4java.sourceforge.net/sites/nl4j-runtime-parent/bridj/apidocs/com/bridj/Pointer.html Pointer class' Javadoc].

In BridJ, each pointer exposes the following data :
  * a peer, which is the long value of the memory address it points to.
  * a target type, which is null for `Pointer<?>` instances.
  * a byte order (as NIO buffers), which states whether data will be read from this pointer in big endian or little endian mode

TODO

= Reading / Writing data = 

{{{
Pointer<Integer> pInt = ...;
// Here are 4 ways to get the int value pointed directly by pInt :
int v = pInt.get();
v = pInt.get(0); // element offset (in ints)
v = pInt.getInt();
v = pInt.getInt(0); // byte offset (in bytes)
}}}

TODO

= Allocating memory =

TODO

= Wrapping memory =

TODO

= Memory bounds, offsets, iteration = 

== Offsets ==

In C, one can increment a pointer with `ptr++`. The expression `ptr + x`, where `x` is an integer, gives a pointer to the same memory location as `ptr` shifted by `x` elements.

If `ptr` is an int pointer, the address pointed by `ptr + 1` is the address pointed by `ptr` plus 4 bytes.

With BridJ, given a pointer `ptr`, one can get `ptr + 1` with `ptr.next(1)`.

The method `ptr.offset(1)` shifts the pointer by 1 byte, whereas `ptr.next(1)` shifts the pointer by 1 element (4 bytes if the target type of the pointer is Integer).

== Bounds ==

Memory allocated from Java using Pointer.allocateXXX and Pointer.pointerToXXX methods has known valid bounds. Pointers that wrap direct NIO buffers also have known valid bounds that they take from the buffer.

Read/write operations on such "bounded" pointers are bounds-checked and throw exceptions when indexes are out of bounds :

{{{
import static com.bridj.Pointer.*;
...
allocateInt().getLong(); // will throw : allocated an int = 4 bytes, reading a long = 8 bytes
allocateShort(3).get(3); // will throw : allocated 3 shorts, reading short at index 3
allocateInts(2).next(1).get(-1); // will not throw : allocated 2 ints, offsetting a pointer by 1 element and reading the element before (nulling the offset)
}}}

It is possible to ask a pointer how many valid bytes are available from its pointed location :
{{{
Pointer<Short> p = allocateShorts(4); // allocate 4 * 2 bytes = 8 bytes
System.out.println(p.getRemainingBytes()); // 8
Pointer<Short> p2 = p.next(); // shift pointer by 1 short = 2 bytes.
System.out.println(p2.getRemainingBytes()); // 6
}}}

== Iteration ==

One can iterate over a pointer :
{{{
Pointer<Integer> pInts = pointerToInts(1, 2, 3, 4, 5);
for (int v : pInts)
  System.out.println(v);
}}}

If the pointer's bounds are unknown, iteration will be infinite (until illegal memory access is attempted, which will most likely crash the JVM).

= Typed pointers =

A typed pointer is a subclass of the `Pointer<?>` class that corresponds in C to some void pointer or opaque pointer typedef :
{{{
typedef void* HWND;
typedef struct _S* S;
}}}

TODO

= Endianness =

TODO

= Casting =

TODO